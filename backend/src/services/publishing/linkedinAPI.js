/**
 * Marketing Machine - LinkedIn API Integration
 * Phase 7: Smart Publishing System
 */

const axios = require('axios');
const logger = require('../../utils/logger');
const { ValidationError, UnauthorizedError } = require('../../utils/errors');

class LinkedInAPI {
  constructor(accessToken, companyId) {
    this.accessToken = accessToken;
    this.companyId = companyId;
    this.baseURL = 'https://api.linkedin.com/v2';
    this.apiClient = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json',
        'X-Restli-Protocol-Version': '2.0.0'
      },
      timeout: 30000
    });
  }

  /**
   * Get user profile information
   */
  async getUserProfile() {
    try {
      const response = await this.apiClient.get('/people/~:(id,firstName,lastName,emailAddress)');
      return response.data;
    } catch (error) {
      logger.error('Failed to fetch LinkedIn user profile:', {
        error: error.message,
        status: error.response?.status
      });
      
      if (error.response?.status === 401) {
        throw new UnauthorizedError('LinkedIn access token is invalid or expired');
      }
      
      throw new Error(`Failed to fetch user profile: ${error.message}`);
    }
  }

  /**
   * Get company page information
   */
  async getCompanyPage(companyPageId) {
    try {
      const response = await this.apiClient.get(
        `/organizationAcls?q=roleAssignee&role=ADMINISTRATOR&projection=(elements*(organizationalTarget~(id,localizedName)))`
      );
      
      const companies = response.data.elements || [];
      const targetCompany = companies.find(
        company => company.organizationalTarget?.id === companyPageId
      );
      
      if (!targetCompany) {
        throw new Error('Company page not found or insufficient permissions');
      }
      
      return targetCompany.organizationalTarget;
    } catch (error) {
      logger.error('Failed to fetch LinkedIn company page:', {
        error: error.message,
        companyPageId
      });
      
      throw new Error(`Failed to fetch company page: ${error.message}`);
    }
  }

  /**
   * Publish text post to LinkedIn
   */
  async publishTextPost(content, visibility = 'PUBLIC') {
    try {
      const postData = {
        author: `urn:li:person:${await this.getPersonId()}`,
        lifecycleState: 'PUBLISHED',
        specificContent: {
          'com.linkedin.ugc.ShareContent': {
            shareCommentary: {
              text: content
            },
            shareMediaCategory: 'NONE'
          }
        },
        visibility: {
          'com.linkedin.ugc.MemberNetworkVisibility': visibility
        }
      };

      const response = await this.apiClient.post('/ugcPosts', postData);
      
      logger.info('LinkedIn text post published successfully:', {
        postId: response.data.id,
        contentLength: content.length
      });
      
      return {
        id: response.data.id,
        url: `https://www.linkedin.com/feed/update/${response.data.id}/`,
        publishedAt: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Failed to publish LinkedIn text post:', {
        error: error.message,
        status: error.response?.status,
        contentLength: content?.length
      });
      
      if (error.response?.status === 401) {
        throw new UnauthorizedError('LinkedIn access token is invalid or expired');
      }
      
      throw new Error(`Failed to publish text post: ${error.message}`);
    }
  }

  /**
   * Publish post with image to LinkedIn
   */
  async publishImagePost(content, imageUrl, visibility = 'PUBLIC') {
    try {
      // Step 1: Upload image to LinkedIn
      const uploadedImageUrn = await this.uploadImage(imageUrl);
      
      // Step 2: Create post with image
      const postData = {
        author: `urn:li:person:${await this.getPersonId()}`,
        lifecycleState: 'PUBLISHED',
        specificContent: {
          'com.linkedin.ugc.ShareContent': {
            shareCommentary: {
              text: content
            },
            shareMediaCategory: 'IMAGE',
            media: [{
              status: 'READY',
              description: {
                text: 'Generated by Marketing Machine'
              },
              media: uploadedImageUrn,
              title: {
                text: 'Marketing Machine Generated Content'
              }
            }]
          }
        },
        visibility: {
          'com.linkedin.ugc.MemberNetworkVisibility': visibility
        }
      };

      const response = await this.apiClient.post('/ugcPosts', postData);
      
      logger.info('LinkedIn image post published successfully:', {
        postId: response.data.id,
        imageUrn: uploadedImageUrn
      });
      
      return {
        id: response.data.id,
        url: `https://www.linkedin.com/feed/update/${response.data.id}/`,
        publishedAt: new Date().toISOString(),
        imageUrn: uploadedImageUrn
      };
    } catch (error) {
      logger.error('Failed to publish LinkedIn image post:', {
        error: error.message,
        imageUrl
      });
      
      throw new Error(`Failed to publish image post: ${error.message}`);
    }
  }

  /**
   * Upload image to LinkedIn
   */
  async uploadImage(imageUrl) {
    try {
      const personId = await this.getPersonId();
      
      // Step 1: Register upload
      const registerResponse = await this.apiClient.post('/assets?action=registerUpload', {
        registerUploadRequest: {
          recipes: ['urn:li:digitalmediaRecipe:feedshare-image'],
          owner: `urn:li:person:${personId}`,
          serviceRelationships: [{
            relationshipType: 'OWNER',
            identifier: 'urn:li:userGeneratedContent'
          }]
        }
      });

      const uploadUrl = registerResponse.data.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
      const asset = registerResponse.data.value.asset;

      // Step 2: Download image from URL
      const imageResponse = await axios.get(imageUrl, { responseType: 'arraybuffer' });
      const imageBuffer = Buffer.from(imageResponse.data);

      // Step 3: Upload to LinkedIn
      await axios.put(uploadUrl, imageBuffer, {
        headers: {
          'Content-Type': 'application/octet-stream'
        }
      });

      logger.info('Image uploaded to LinkedIn successfully:', {
        asset,
        imageUrl,
        size: imageBuffer.length
      });

      return asset;
    } catch (error) {
      logger.error('Failed to upload image to LinkedIn:', {
        error: error.message,
        imageUrl
      });
      
      throw new Error(`Failed to upload image: ${error.message}`);
    }
  }

  /**
   * Get LinkedIn person ID from profile
   */
  async getPersonId() {
    if (this.personId) {
      return this.personId;
    }

    try {
      const profile = await this.getUserProfile();
      this.personId = profile.id;
      return this.personId;
    } catch (error) {
      throw new Error(`Failed to get person ID: ${error.message}`);
    }
  }

  /**
   * Get post analytics/insights
   */
  async getPostAnalytics(postId, metrics = ['CLICK_COUNT', 'IMPRESSION_COUNT', 'LIKE_COUNT', 'COMMENT_COUNT', 'SHARE_COUNT']) {
    try {
      const response = await this.apiClient.get(
        `/socialActions/${postId}/analytics?timeGranularity=DAY&metrics=${metrics.join(',')}`
      );
      
      return response.data;
    } catch (error) {
      logger.warn('Failed to fetch post analytics:', {
        postId,
        error: error.message
      });
      
      return null;
    }
  }

  /**
   * Validate access token and permissions
   */
  async validateToken() {
    try {
      await this.getUserProfile();
      return true;
    } catch (error) {
      logger.error('LinkedIn token validation failed:', error.message);
      return false;
    }
  }

  /**
   * Get optimal posting times based on LinkedIn insights
   */
  async getOptimalPostingTimes() {
    try {
      // This would typically call LinkedIn's analytics API
      // For now, return default optimal times based on research
      return {
        weekdays: {
          tuesday: ['09:00', '10:00', '17:00'],
          wednesday: ['09:00', '10:00', '17:00'],
          thursday: ['09:00', '10:00', '17:00']
        },
        timezone: 'UTC',
        confidence: 0.7
      };
    } catch (error) {
      logger.warn('Failed to get optimal posting times:', error.message);
      
      // Return fallback times
      return {
        weekdays: {
          tuesday: ['09:00', '17:00'],
          wednesday: ['09:00', '17:00'],
          thursday: ['09:00', '17:00']
        },
        timezone: 'UTC',
        confidence: 0.5
      };
    }
  }
}

module.exports = LinkedInAPI;